<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
    <meta name="mobile-web-app-capable" content="yes">
    <base target="_blank">

    <title>Skeleton 3d reconstruction</title>

    <script src="js/jquery-3.1.1.min.js"></script>
    <script src="js/tfjs.js"></script>
    <script src="js/posenet.js"></script>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/WebGL.js"></script>

    <link href="css/bootstrap.min.css" rel="stylesheet">
</head>

<body>
<div id="wrapper" class="centered">
    <div style="position: absolute" id="info"></div>
    <div>
        <div class="col-1 col"></div>
        <div class="col-10 col">
            <div class="row" style="margin: 10px">
                <button class="btn" onclick="startWebcam();">Start WebCam</button>
                <button style="margin-left: 20px" class="btn" onclick="stopWebcam();">Stop WebCam</button>
                <button style="margin-left: 20px" class="btn" onclick="usage();">How to use</button>
            </div>
            <div class="row">
                <div class="col-6">
                    <div class="video-wrapper local">
                        <video style="position: absolute;"
                               id="video"
                               width="400px"
                               height="300px"
                               autoplay=""
                               playsinline=""></video>
                        <canvas style="position: absolute;border: #1c7430 solid 2px;display: inline-block"
                                id="myCanvas"
                                width="400px"
                                height="300px"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script type="text/javascript">

    let localStream;                                // web cam

    let networks;                                   // tensorflojs network

    let currentAnimationId;                         // animation id

    let camera, controls, scene, renderer;          // 3d world

    let joints_sample = [];                         // 2d joints will be send to the backend, as the 2nd networks input

    let joints_sample_3d = [];                      // joints received from the backend

    let lines_3d = [];                              // have access to drawn lines to conveniently destroy

    const indexMap2d = {
        'centerHip': 0,
        'leftHip': 1,
        'leftKnee': 2,
        'leftAnkle': 3,
        'rightHip': 4,
        'rightKnee': 5,
        'rightAnkle': 6,
        'spine': 7,
        'centerShoulder': 8,
        'head': 9,
        'leftShoulder': 10,
        'leftElbow': 11,
        'leftWrist': 12,
        'rightShoulder': 13,
        'rightElbow': 14,
        'rightWrist': 15
    };

    const indexMap3d = {                            // joints index agreement
        'rightHip': 0,
        'rightKnee': 1,
        'rightAnkle': 2,
        'leftHip': 3,
        'leftKnee': 4,
        'leftAnkle': 5,
        'centerHip': 6,
        'spine': 7,
        'centerShoulder': 8,
        'head': 9,
        'leftShoulder': 10,
        'leftElbow': 11,
        'leftWrist': 12,
        'rightShoulder': 13,
        'rightElbow': 14,
        'rightWrist': 15
    };

    const linePairs = [
        ['head', 'centerShoulder'],
        ['centerShoulder', 'centerHip'],
        ['leftShoulder', 'rightShoulder'],
        ['leftShoulder', 'leftElbow'],
        ['leftElbow', 'leftWrist'],
        ['rightShoulder', 'rightElbow'],
        ['rightElbow', 'rightWrist'],
        ['centerHip', 'leftHip'],
        ['leftHip', 'leftKnee'],
        ['leftKnee', 'leftAnkle'],
        ['leftKnee', 'leftAnkle'],
        ['centerHip', 'rightHip'],
        ['rightHip', 'rightKnee'],
        ['rightKnee', 'rightAnkle'],
    ];

    const scaleFactor = 0.50;                       // 2d networks configurations
    const flipHorizontal = false;
    const outputStride = 16;
    const scoreThreshold = 0.78;

    // 2d drawing canvas and webcam element
    const imageElement = document.getElementById('video');
    const canvasElement = document.getElementById("myCanvas");

    // 2nd part networks are served through backend
    const server = "ws://localhost:8001";
    const socket = new WebSocket(server);

    init();
    animate();

    // 2D drawing

    /**
     * Draw 2d lines on canvas
     * */
    function drawLine(_from, _to) {
        let ctx = canvasElement.getContext("2d");
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#00ff00';
        ctx.moveTo(_from['position'].x, _from['position'].y);
        ctx.lineTo(_to['position'].x, _to['position'].y);
        ctx.stroke();
    }

    // 3D drawing

    /**
     * Build joints_sample_3d from the result received from backend, a 48d vector.
     * joints_sample_3d will be a 16 x 3 2d array
     */
    function convertTo3dJoints(result) {
        for (let i = 0; i < result.length; ++i) {
            joints_sample_3d[parseInt(i / 3)][i % 3] = result[i];
        }
    }

    /**
     *
     */
    function startWebcam() {
        if (navigator.getUserMedia) {
            navigator.getUserMedia(
                {video: true, audio: false},
                stream => {
                    localStream = stream;
                    $('.local video').attr('src', URL.createObjectURL(stream));
                    // load the posenet model
                    posenet.load().then(function (net) {
                        // posenet model loaded
                        networks = net;
                        updateCanvas();
                    });
                },
                error => {
                    alert('error while accessing usermedia ' + error.toString());
                }
            );
        } else {
            console.log("getUserMedia not supported");
        }
    }

    /**
     * Usage tutorial
     * */
    function usage() {
        alert(
            "1. Start by clicking 'Start WebCam'\n" +
            "2. Make sure a full human body shows in the camera\n" +
            "3. The 3D constructed joints character will appear"
        );
    }

    function stopWebcam() {
        try {
            localStream.stop();
        } catch (e) {
            console.log(e);
            if (localStream) {
                localStream.getTracks().forEach(function (track) {
                    track.stop();
                });
            }
        }
        localStream = undefined;
    }

    /**
     * Use current image element's content to request 2d joints prediction and draw on the canvas
     * */
    function updateCanvas() {

        if (!localStream) {
            window.cancelAnimationFrame(currentAnimationId);
            return;
        }

        networks.estimateSinglePose(imageElement, scaleFactor, flipHorizontal, outputStride).then(function (result) {

            let joints = {};
            for (let i = 0; i < result['keypoints'].length; ++i) {
                joints[result['keypoints'][i]['part']] = result['keypoints'][i];
            }

            // calculate center shoulder
            joints['centerShoulder'] = {
                score: (joints['leftShoulder']['score'] + joints['rightShoulder']['score']) * 0.5,
                part: 'centerShoulder',
                position: {
                    x: (joints['leftShoulder']['position'].x + joints['rightShoulder']['position'].x) * 0.5,
                    y: (joints['leftShoulder']['position'].y + joints['rightShoulder']['position'].y) * 0.5
                },
            };
            joints['centerHip'] = {
                score: (joints['leftHip']['score'] + joints['rightHip']['score']) * 0.5,
                part: 'centerHip',
                position: {
                    x: (joints['leftHip']['position'].x + joints['rightHip']['position'].x) * 0.5,
                    y: (joints['leftHip']['position'].y + joints['rightHip']['position'].y) * 0.5,
                },
            };
            joints['spine'] = {
                score: (joints['centerHip']['score'] + joints['centerShoulder']['score']) * 0.5,
                part: 'spine',
                position: {
                    x: (joints['centerHip']['position'].x + joints['centerShoulder']['position'].x) * 0.5,
                    y: (joints['centerHip']['position'].y + joints['centerShoulder']['position'].y) * 0.5,
                },
            };
            joints['head'] = joints['nose'];

            let ctx = canvasElement.getContext("2d");
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            for (let i = 0; i < linePairs.length; ++i) {
                if (joints[linePairs[i][0]]['score'] > scoreThreshold && joints[linePairs[i][1]]['score']) {
                    drawLine(joints[linePairs[i][0]], joints[linePairs[i][1]]);
                }
            }

            if (result['score'] > scoreThreshold) {
                joints_sample = [];
                for (let key in indexMap2d) {
                    joints_sample.push([joints[key]['position'].x, joints[key]['position'].y]);
                }
                socket.send(joints_sample);
            }
        });

        setTimeout(function(){
            currentAnimationId = requestAnimationFrame(updateCanvas);
        }, 100);

    }

    function normalize2d(array_2d, scale = 1.0) {
        let _min = Infinity;
        let _max = -Infinity;

        for (let i = 0; i < array_2d.length; ++i) {
            for (let j = 0; j < array_2d[i].length; ++j) {
                _min = Math.min(_min, array_2d[i][j]);
                _max = Math.max(_max, array_2d[i][j]);
            }
        }

        for (let i = 0; i < array_2d.length; ++i) {
            for (let j = 0; j < array_2d[i].length; ++j) {
                array_2d[i][j] = scale * (array_2d[i][j] - _min) / (_max - _min);
            }
        }

        return array_2d
    }

    function generateVec3(joint_index, x_offset = 0, y_offset = 100, z_offset = 0) {
        return new THREE.Vector3(0.2 * joints_sample_3d[joint_index][0] + x_offset, -0.2 * joints_sample_3d[joint_index][1] + y_offset, 0.2 * joints_sample_3d[joint_index][2] + z_offset);
    }


    function init() {

        for (let i = 0; i < 16; ++i) {
            joints_sample_3d.push([0.0, 0.0, 0.0]);
        }

        // connect to backend service

        socket.onerror = function (error) {
            alert("Socket server " + server + " is not opening!!");
        };

        socket.addEventListener('open', function (event) {
            socket.send('Hi service.');
        });

        socket.addEventListener('message', function (event) {
            let result;
            try {
                result = JSON.parse(event.data)
            } catch (e) {
                console.log("received message format", e);
                return;
            }
            convertTo3dJoints(result);
        });

        // set up 3d scene

        if (WEBGL.isWebGLAvailable() === false) {
            document.getElementById("info").appendChild(WEBGL.getWebGLErrorMessage());
        }

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x00ccff);
        scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("info").appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(400, 200, 0);

        // controls

        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        // controls.dampingFactor = 0.25;

        controls.screenSpacePanning = false;

        controls.minDistance = 100;
        controls.maxDistance = 500;

        controls.maxPolarAngle = Math.PI / 2;

        // world

        let axesHelper = new THREE.AxesHelper(1000);
        scene.add(axesHelper);

        // ground
        let mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000), new THREE.MeshPhongMaterial({
            color: 0x999999,
            depthWrite: false
        }));
        mesh.rotation.x = -Math.PI / 2;
        scene.add(mesh);
        let grid = new THREE.GridHelper(200, 40, 0x000000, 0x000000);
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add(grid);

        // lights

        let light = new THREE.HemisphereLight(0xffffff, 0x444444);
        light.position.set(0, 20, 0);
        scene.add(light);
        light = new THREE.DirectionalLight(0xffffff);
        light.position.set(0, 20, 10);
        scene.add(light);

        window.addEventListener('resize', onWindowResize, false);
    }

    function setLine(start, end) {
        // console.log(start);
        let material = new THREE.LineBasicMaterial({
            color: 0x000000,
            linewidth: 10,
            linecap: 'round', //ignored by WebGLRenderer
            linejoin: 'round' //ignored by WebGLRenderer
        });
        // material.linewidth = 100.0;
        // material.lights = true;
        let geometry = new THREE.Geometry();
        geometry.vertices.push(start);
        geometry.vertices.push(end);
        // geometry.vertices.push(new THREE.Vector3(10, 0, 0));
        let line = new THREE.LineSegments(geometry, material);
        lines_3d.push(line);
        scene.add(line);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        if (joints_sample_3d.length > 0 && (joints_sample_3d[0][0] !== 0) || (joints_sample_3d[0][1] !== 0) || (joints_sample_3d[0][2] !== 0)) {
            for (let i = 0; i < lines_3d.length; ++i) {
                scene.remove(lines_3d[i]);
                lines_3d[i].geometry.dispose();
                lines_3d[i].material.dispose();
            }
            lines_3d = [];
            for (let i = 0; i < linePairs.length; ++i) {
                setLine(generateVec3(indexMap3d[linePairs[i][0]]), generateVec3(indexMap3d[linePairs[i][1]]));
            }
        }
        requestAnimationFrame(animate);
        render();
    }

    function render() {
        renderer.render(scene, camera);
    }

</script>
</body>
</html>