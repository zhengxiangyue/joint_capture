<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
    <meta name="mobile-web-app-capable" content="yes">
    <base target="_blank">

    <title>Skeleton 3d reconstruction</title>

    <script src="js/jquery-3.1.1.min.js"></script>
    <script src="js/tfjs.js"></script>
    <script src="js/posenet.js"></script>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/WebGL.js"></script>

    <link href="css/bootstrap.min.css" rel="stylesheet">

    <style>
        #video {
            -webkit-transform: scaleX(-1);
            transform: scaleX(-1);
        }
    </style>
</head>

<body>
<div id="wrapper" class="centered">
    <div style="position: absolute" id="info"></div>

    <div id="log">
    </div>

    <div>
        <div class="col-1 col"></div>
        <div class="col-10 col">
            <div class="row" style="margin: 10px">
                <button class="btn" onclick="startWebcam();">Start WebCam</button>
                <button style="margin-left: 20px" class="btn" onclick="startVideo();">Start Video</button>
                <button style="margin-left: 20px" class="btn" onclick="stopWebcam();">Stop WebCam</button>
                <button style="margin-left: 20px" class="btn" onclick="usage();">How to use</button>
            </div>
            <div class="row">
                <div class="col-6">
                    <div class="video-wrapper local">
                        <video id="video"
                               style="position: absolute;width: 300px"
                               autoplay=""
                               playsinline=""></video>
                        <canvas style="position: absolute;z-index: 1"
                                id="poseCanvas"></canvas>
                        <canvas style="display:none;position: absolute;z-index: 0" id="imageCanvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script type="text/javascript">

    let localStream;                                // web cam

    let networks;                                   // tensorflojs network

    let currentAnimationId;                         // animation id

    let camera, controls, scene, renderer;          // 3d world

    let joints_sample = [];                         // 2d joints will be send to the backend, as the 2nd networks input

    let joints_sample_3d = [];                      // joints received from the backend

    let lines_3d = [];                              // have access to drawn lines to conveniently destroy
    let sphere_3d = [];

    const indexMap2d = {
        'centerHip': 0,
        'leftHip': 1,
        'leftKnee': 2,
        'leftAnkle': 3,
        'rightHip': 4,
        'rightKnee': 5,
        'rightAnkle': 6,
        'spine': 7,
        'centerShoulder': 8,
        'head': 9,
        'leftShoulder': 10,
        'leftElbow': 11,
        'leftWrist': 12,
        'rightShoulder': 13,
        'rightElbow': 14,
        'rightWrist': 15
    };

    const indexMap3d = {                            // joints index agreement
        'leftHip': 0,
        'leftKnee': 1,
        'leftAnkle': 2,
        'rightHip': 3,
        'rightKnee': 4,
        'rightAnkle': 5,
        'centerHip': 6,
        'spine': 7,
        'centerShoulder': 8,
        'head': 9,
        'leftShoulder': 10,
        'leftElbow': 11,
        'leftWrist': 12,
        'rightShoulder': 13,
        'rightElbow': 14,
        'rightWrist': 15
    };

    const linePairs = [                             // lines that consit a human skeleton
        ['head', 'centerShoulder'],
        ['centerShoulder', 'spine'],
        ['spine', 'centerHip'],
        ['leftShoulder', 'centerShoulder'],
        ['centerShoulder', 'rightShoulder'],
        ['leftShoulder', 'leftElbow'],
        ['leftElbow', 'leftWrist'],
        ['rightShoulder', 'rightElbow'],
        ['rightElbow', 'rightWrist'],
        ['centerHip', 'leftHip'],
        ['leftHip', 'leftKnee'],
        ['leftKnee', 'leftAnkle'],
        ['leftKnee', 'leftAnkle'],
        ['centerHip', 'rightHip'],
        ['rightHip', 'rightKnee'],
        ['rightKnee', 'rightAnkle'],
    ];

    const scaleFactor = 0.50;                       // 2d networks configurations
    const flipHorizontal = true;
    const outputStride = 16;
    const scoreThreshold = 0.58;

    let canvasFactor;

    // 2d drawing canvas and webcam element
    const imageElement = document.getElementById('video');
    const poseCanvasElement = document.getElementById("poseCanvas");
    const imageCanvasElement = document.getElementById("imageCanvas");

    const poseContext = poseCanvasElement.getContext("2d");
    const imageContext = imageCanvasElement.getContext("2d");

    // 2nd part networks are served through backend
    const server = "ws://localhost:8001";
    const socket = new WebSocket(server);

    // 2D drawing

    /**
     * Draw 2d lines on canvas
     * */
    function drawLine(_from, _to) {
        poseContext.beginPath();
        poseContext.lineWidth = 2;
        poseContext.strokeStyle = '#00ff00';
        poseContext.moveTo(canvasFactor * _from['position'].x, canvasFactor * _from['position'].y);
        poseContext.lineTo(canvasFactor * _to['position'].x, canvasFactor * _to['position'].y);
        poseContext.stroke();
    }

    /**
     *
     * @param array_2d
     * @param scale
     * @returns {*}
     */
    function normalize2d(array_2d, scale = 1.0) {
        let _min = Infinity;
        let _max = -Infinity;

        for (let i = 0; i < array_2d.length; ++i) {
            for (let j = 0; j < array_2d[i].length; ++j) {
                _min = Math.min(_min, array_2d[i][j]);
                _max = Math.max(_max, array_2d[i][j]);
            }
        }

        for (let i = 0; i < array_2d.length; ++i) {
            for (let j = 0; j < array_2d[i].length; ++j) {
                array_2d[i][j] = scale * (array_2d[i][j] - _min) / (_max - _min);
            }
        }

        return array_2d
    }

    /**
     * Use current image element's content to request 2d joints prediction and draw on the canvas
     * */
    function updateCanvas() {

        // get canvas data from img
        imageContext.drawImage(imageElement, 0, 0);

        // console.log(c.toDataURL());
        networks.estimateSinglePose(imageCanvasElement, scaleFactor, flipHorizontal, outputStride).then(function (result) {

            let joints = {};
            for (let i = 0; i < result['keypoints'].length; ++i) {
                joints[result['keypoints'][i]['part']] = result['keypoints'][i];
            }

            // calculate center shoulder
            joints['centerShoulder'] = {
                score: (joints['leftShoulder']['score'] + joints['rightShoulder']['score']) * 0.5,
                part: 'centerShoulder',
                position: {
                    x: (joints['leftShoulder']['position'].x + joints['rightShoulder']['position'].x) * 0.5,
                    y: (joints['leftShoulder']['position'].y + joints['rightShoulder']['position'].y) * 0.5
                },
            };
            joints['centerHip'] = {
                score: (joints['leftHip']['score'] + joints['rightHip']['score']) * 0.5,
                part: 'centerHip',
                position: {
                    x: (joints['leftHip']['position'].x + joints['rightHip']['position'].x) * 0.5,
                    y: (joints['leftHip']['position'].y + joints['rightHip']['position'].y) * 0.5 - 40,
                },
            };
            joints['spine'] = {
                score: (joints['centerHip']['score'] + joints['centerShoulder']['score']) * 0.5,
                part: 'spine',
                position: {
                    x: (joints['centerHip']['position'].x + joints['centerShoulder']['position'].x) * 0.5,
                    y: (joints['centerHip']['position'].y + joints['centerShoulder']['position'].y) * 0.5,
                },
            };

            joints['leftAnkle'].position.y -= 20;
            joints['rightAnkle'].position.y -= 20;

            joints['leftKnee'].position.y -= 30;
            joints['rightKnee'].position.y -= 30;

            joints['head'] = joints['nose'];

            poseContext.clearRect(0, 0, poseCanvasElement.width, poseCanvasElement.height);

            for (let i = 0; i < linePairs.length; ++i) {
                if (joints[linePairs[i][0]]['score'] > scoreThreshold && joints[linePairs[i][1]]['score']) {
                    drawLine(joints[linePairs[i][0]], joints[linePairs[i][1]]);
                }
            }

            if (result['score'] > scoreThreshold) {
                joints_sample = [];
                for (let key in indexMap2d) {
                    joints_sample.push([joints[key]['position'].x, joints[key]['position'].y]);
                }
                console.log(JSON.stringify(joints_sample));
                socket.send(joints_sample);
            }
        });

        setTimeout(function () {
            currentAnimationId = requestAnimationFrame(updateCanvas);
        }, 100);

    }

    // 3D drawing

    /**
     * Build joints_sample_3d from the result received from backend, a 48d vector.
     * joints_sample_3d will be a 16 x 3 2d array
     */
    function convertTo3dJoints(result) {
        for (let i = 0; i < result.length; ++i) {
            joints_sample_3d[parseInt(i / 3)][i % 3] = result[i];
        }
    }

    /**
     * Draw 3d line in the scene
     * @param start
     * @param end
     * @param color
     */
    function setLine(start, end, color = 0x000000) {
        let material = new THREE.LineBasicMaterial({
            color: color,
            linewidth: 10,
            linecap: 'round', //ignored by WebGLRenderer
            linejoin: 'round' //ignored by WebGLRenderer
        });
        // material.linewidth = 100.0;
        // material.lights = true;
        let geometry = new THREE.Geometry();
        geometry.vertices.push(start);
        geometry.vertices.push(end);
        // geometry.vertices.push(new THREE.Vector3(10, 0, 0));
        let line = new THREE.LineSegments(geometry, material);
        lines_3d.push(line);
        scene.add(line);
    }

    /**
     * Draw sphere in the scene
     */
    function setSphere(position, radius, color = 0xffff00) {
        var geometry = new THREE.SphereBufferGeometry(radius, 8, 8);
        var material = new THREE.MeshPhongMaterial({color: color});
        var sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(position.x, position.y, position.z);
        scene.add(sphere);
        sphere_3d.push(sphere);
        //
    }

    /**
     * Based on current content in joints_sample_3d, draw the line pairs in the scene
     */
    function updateScene() {
        if (joints_sample_3d.length > 0 && (joints_sample_3d[0][0] !== 0) || (joints_sample_3d[0][1] !== 0) || (joints_sample_3d[0][2] !== 0)) {
            for (let i = 0; i < lines_3d.length; ++i) {
                scene.remove(lines_3d[i]);
                lines_3d[i].geometry.dispose();
                lines_3d[i].material.dispose();
            }
            lines_3d = [];

            for (let i = 0; i < sphere_3d.length; ++i) {
                scene.remove(sphere_3d[i]);
                sphere_3d[i].geometry.dispose();
                sphere_3d[i].material.dispose();
            }
            sphere_3d = [];

            for (let i = 0; i < linePairs.length; ++i) {
                setLine(generateVec3(indexMap3d[linePairs[i][0]]), generateVec3(indexMap3d[linePairs[i][1]]), linePairs[i][2]);
            }

            for (let each in indexMap3d) {
                setSphere(generateVec3(indexMap3d[each]), 5, 'gray');
            }
        }
    }

    /**
     *
     * @param joint_index
     * @param x_offset
     * @param y_offset
     * @param z_offset
     * @returns {Vector3}
     */
    function generateVec3(joint_index, x_offset = 0, y_offset = 200, z_offset = 0) {
        let world_coordinate = new THREE.Vector3(0.2 * joints_sample_3d[joint_index][0] + x_offset, -0.2 * joints_sample_3d[joint_index][1] + y_offset, 0.2 * joints_sample_3d[joint_index][2] + z_offset);
        world_coordinate.applyAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 4);
        return world_coordinate;
    }

    // infrastructures

    /**
     * Alert messages for usage
     */
    function usage() {
        alert(
            "1. Start server srcipt src/run_webcam.py \n" +
            "2. Refresh this page \n"
        );
    }

    /**
     * Open camera, while set up the 1st part network
     */
    function startWebcam() {
        if (navigator.getUserMedia) {
            navigator.getUserMedia(
                {video: true, audio: false, video: {width: 1024}},
                stream => {
                    localStream = stream;
                    $('.local video').attr('src', URL.createObjectURL(stream));
                    // load the posenet model
                    posenet.load().then(function (net) {
                        // posenet model loaded
                        networks = net;

                        imageContext.canvas.width = imageElement.videoWidth;
                        imageContext.canvas.height = imageElement.videoHeight;

                        updateCanvas();
                    });
                },
                error => {
                    alert('error while accessing usermedia ' + error.toString());
                }
            );
        } else {
            console.log("getUserMedia not supported");
        }
    }


    function startVideo() {

        posenet.load().then(function (net) {
            // posenet model loaded
            networks = net;
            // imageElement.src = "sample.mp4";
            // imageElement.src = "sample2.mov";
            imageElement.src = "sample6.webm";
            imageElement.load();

            setTimeout(function () {
                imageContext.canvas.width = imageElement.videoWidth;
                imageContext.canvas.height = imageElement.videoHeight;
                canvasFactor = 300.0 / imageElement.videoWidth;
                poseContext.canvas.width = 300;
                poseContext.canvas.height = 300.0 * imageElement.videoHeight / imageElement.videoWidth;
                updateCanvas();
            }, 3000);

        });
    }

    /**
     * Stop camera
     */
    function stopWebcam() {
        try {
            localStream.stop();
        } catch (e) {
            console.log(e);
            if (localStream) {
                localStream.getTracks().forEach(function (track) {
                    track.stop();
                });
            }
        }
        localStream = undefined;
    }

    /**
     * Things start here
     */
    function init() {

        for (let i = 0; i < 16; ++i) {
            joints_sample_3d.push([0.0, 0.0, 0.0]);
        }

        // connect to backend service

        socket.onerror = function (error) {
            alert("Socket server " + server + " is not opening!!");
        };

        socket.addEventListener('open', function (event) {
            socket.send('Hi service.');
        });

        socket.addEventListener('message', function (event) {
            let result;
            try {
                result = JSON.parse(event.data);
            } catch (e) {
                console.log("received message format", e);
                return;
            }
            convertTo3dJoints(result);
        });

        // set up 3d scene

        if (WEBGL.isWebGLAvailable() === false) {
            document.getElementById("info").appendChild(WEBGL.getWebGLErrorMessage());
        }

        scene = new THREE.Scene();

        // sky
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.FogExp2(0xcccccc, 0.0002);

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("info").appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.set(400, 200, 0);

        // controls

        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
        // controls.dampingFactor = 0.25;

        controls.screenSpacePanning = false;

        controls.minDistance = 0;
        controls.maxDistance = 2000;

        controls.maxPolarAngle = Math.PI / 2;

        // world

        let axesHelper = new THREE.AxesHelper(1100);
        scene.add(axesHelper);

        // ground
        let mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000), new THREE.MeshPhongMaterial({
            color: 0x666666,
            depthWrite: false
        }));
        mesh.rotation.x = -Math.PI / 2;
        scene.add(mesh);

        let grid = new THREE.GridHelper(2000, 100, 0x000000, 0x000000);
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add(grid);

        // lights

        let light = new THREE.HemisphereLight(0xffffff, 0x444444);
        light.position.set(0, 20, 0);
        scene.add(light);
        light = new THREE.DirectionalLight(0xffffff);
        light.position.set(0, 20, 10);
        scene.add(light);

        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        updateScene()
        requestAnimationFrame(animate);
        render();
    }

    function render() {
        renderer.render(scene, camera);
    }

    init();
    animate();
</script>
</body>
</html>